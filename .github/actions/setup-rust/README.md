# Setup Rust

Install the Rust toolchain and cache your build dependencies. Optionally
install PostgreSQL and SQLite system libraries for crates that require
them.

## Inputs

| Name | Description | Required | Default |
| --- | --- | --- | --- |
| install-postgres-deps | Install PostgreSQL system dependencies | no | `false` |
| install-sqlite-deps | Install SQLite development libraries (Windows) | no | `false` |
| BUILD_PROFILE | Build profile used for caching | no | `release` |
| use-sccache | Enable sccache for non-release runs | no | `true` |
| sccache-action-version | Version tag for mozilla-actions/sccache-action | no | `v0.0.10` |

## Outputs

None

## Example

```yaml
uses: ./.github/actions/setup-rust@v1
  with:
    install-postgres-deps: true
    install-sqlite-deps: true
    use-sccache: 'false'
```

When `install-postgres-deps` is enabled, the action installs PostgreSQL
client libraries via the package manager for the runner OS. On Linux,
it uses `apt` (`libpq-dev`). On Windows, Chocolatey installs
`postgresql17` and exposes its headers and import libraries through
`PG_INCLUDE` and `PG_LIB` environment variables.

When `install-sqlite-deps` is enabled, the action installs SQLite
development files using MSYS2 on Windows.

SQLite support on Windows is enabled by setting up an MSYS2 environment
with the MinGW toolchain and the `mingw-w64-x86_64-sqlite3` package,
so the static library and headers are available when compiling crates that
depend on SQLite.

```yaml
      # Bring in MSYS2 plus the MinGW build of SQLite
      - name: Install MSYS2 toolchain and SQLite
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          update: true
          install: >-
            mingw-w64-x86_64-toolchain
            mingw-w64-x86_64-sqlite3       # ships libsqlite3.a + headers

      # Build inside the MSYS2 shell so the linker sees /mingw64/lib
      - name: Build
        shell: msys2 {0}
        run: cargo build --workspace --all-targets --verbose
```

## Caching

This action caches `~/.cargo/registry`, `~/.cargo/git` and the build output in
`target/$BUILD_PROFILE` using
[actions/cache](https://github.com/actions/cache). The cache key combines the
operating system, the `BUILD_PROFILE` environment variable and checksums of
`rust-toolchain.toml` and any `Cargo.lock` files.

The cache is restored when this step runs and is saved **after the entire job**
finishes. Any files generated by subsequent build steps therefore become part of
the cached directories.

When the workflow is not triggered by a `release` event and `use-sccache` is
enabled, the action also runs [sccache](https://github.com/mozilla/sccache) to
cache compiler output. It sets `SCCACHE_GHA_ENABLED=true` and
`RUSTC_WRAPPER=sccache` so subsequent build steps benefit from the cache. The
compiled objects are stored in `~/.cache/sccache` and cached with a **separate
cache key** from the directories above. This directory holds the sccache cache
space and does not share data with the standard `actions/cache` entry.

### Requirements

- Set the `BUILD_PROFILE` environment variable (`debug` or `release`) before
  invoking the action so that the cache key is deterministic.

### Extent and limitations

- GitHub limits the total cache size to 5Â GB per repository and OS, so old
  entries may be evicted.
- Caches are scoped to the runner OS; Linux, macOS, and Windows caches are
  independent.
- The cache is best-effort: if the key changes or the cache is evicted, the
  build will proceed without cached artifacts.

### Effective use

- Keep `rust-toolchain.toml` and `Cargo.lock` files checked in to ensure stable
  cache keys.
- Set `BUILD_PROFILE` consistently across jobs. For most CI runs, `release` is a
  good choice.


Release history is available in [CHANGELOG](CHANGELOG.md).
